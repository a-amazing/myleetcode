1.如果使用jvm锁,那么需要根据商品id,分别配置锁
    注意,使用jvm锁时,考虑aop的执行顺序,是先释放锁,再提交事务,还是先提交事务,再释放锁
    先释放锁的情况,可能就会出现超卖的问题!
2.是否可以考虑使用数据库悲观锁,锁商品id
3.基于数据库乐观锁 update where seckilId = #{} and num > #{count}
4.使用redis分布式锁(注意,这边可能会出现和jvm锁一样的问题,即事务尚未提交,但是锁已经开始释放)
    根据springboot-seckill项目的观点,可能是因为远程释放分布式锁需要时间,所以超卖问题相对不严重


